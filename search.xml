<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Laravel框架下使用Hashid对id进行加解密]]></title>
    <url>%2F2017%2F07%2F06%2FLaravel%E6%A1%86%E6%9E%B6%E4%B8%8B%E4%BD%BF%E7%94%A8Hashid%E5%AF%B9id%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[laravel Hashid 整合了 Base62, Hashids, Optimus 等高性能编码算法，并提供了统一的、简单易用的调用接口 应用场景示例： 不希望对外暴露有规则的数据索引，比如用户 ID，商品ID，订单编号…防止被第三方直接遍历抓取资源 版本最低要求：php: &gt;=5.4.0 在laravel中安装hashids 1composer require torann/hashids 在config/app.php中的providers数组中添加 123&apos;providers&apos; =&gt; [ Torann\Hashids\HashidsServiceProvider::class,] 在config下生成hashids.php配置文件 1php artisan vendor:publish --provider=&quot;Torann\Hashids\HashidsServiceProvider&quot; 修改hashids.php要加密的长度 1&apos;length&apos; =&gt; 8, Hashid使用加密 123dd(Hashids::encode(111));结果：LDdwjwb1 Hashid使用解密 12345dd(Hashids::decode(&apos;LDdwjwb1&apos;);结果：array:1 [▼ 0 =&gt; 111 ] 由于限制如果版本高的话可以引用这个 1https://github.com/vinkla/laravel-hashids]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swoole创建基于HttpServer与基于WebSocket服务器]]></title>
    <url>%2F2017%2F07%2F04%2FSwoole%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8EHttpServer%E4%B8%8E%E5%9F%BA%E4%BA%8EWebSocket%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[WebSocket服务器是建立在Http服务器之上的长连接服务器，客户端首先会发送一个Http的请求与服务器进行握手 握手成功后会触发onOpen事件，表示连接已就绪，onOpen函数中可以得到$request对象，包含了Http握手的相关信息，如GET参数、Cookie、Http头信息等。 启动HttpServer服务端 12345678910111213&lt;?php$http = new swoole_http_server(&quot;0.0.0.0&quot;, 8888);$http-&gt;set([ &apos;enable_static_handler&apos;=&gt;true, &apos;document_root&apos; =&gt; &apos;/home/wwwroot/default /swool/demo/server/data&apos; //设置终端执行保存的静态路径]);$http-&gt;on(&apos;request&apos;, function ($request, $response) &#123; $response-&gt;end(&quot;&lt;h1&gt;Hello Swoole. #&quot;.rand(1000, 9999).&quot;&lt;/h1&gt;&quot;);&#125;);$http-&gt;start(); ?&gt; 测试连接 123456789101112131415161718192021222324&lt;?php$server = new swoole_websocket_server(&quot;0.0.0.0&quot;, 9501);//$server-&gt;set([]); 可以设置一些参数//监听_websocket打开事件$server-&gt;on(&apos;open&apos;, &apos;onOpen&apos;);function onOpen($server,$request)&#123; print_r(&quot;我是收到的客户端连接ID:&quot;.$request-&gt;fd); //$fd 客户端连接的ID，如果指定的$fd对应的TCP连接并非websocket 客户端，将会发送失败https://wiki.swoole.com/wiki/page/399.html&#125;//监听ws的消息事件$server-&gt;on(&apos;message&apos;, function (swoole_websocket_server $server, $frame) &#123; echo &quot;receive from &#123;$frame-&gt;fd&#125;:&#123;$frame-&gt;data&#125;, opcode:&#123;$frame-&gt;opcode&#125;,fin:&#123;$frame-&gt;finish&#125;\n&quot;; //websocket客户端连接推送数据，长度最大不得超过2M。 $server-&gt;push($frame-&gt;fd, &quot;this is server&quot;);&#125;);$server-&gt;on(&apos;close&apos;, function ($ser, $fd) &#123; echo &quot;client &#123;$fd&#125; closed\n&quot;;&#125;);$server-&gt;start(); WebSocket client 端 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;websocket客户端测试&lt;/h1&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 打开一个 web socket var ws = new WebSocket(&quot;ws://47.94.166.123:9999/&quot;); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send方法发送数据 ws.send(&quot;发送数据&quot;); console.log(&quot;数据发送中...&quot;); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; console.log(received_msg,2222); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert(&quot;连接已关闭...&quot;); &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1文档地址:https://wiki.swoole.com/wiki/page/479.html]]></content>
      <categories>
        <category>Swoole学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[创建发布一个自己的 Composer/Packagist 包 (PHP)]]></title>
    <url>%2F2017%2F07%2F04%2F%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%20Packagist%20%E5%8C%85%20(PHP)%2F</url>
    <content type="text"><![CDATA[Composer是PHP的一个依赖管理工具，在Packagist上提交了一个自己开发的PHP组件，这样其他开发者就可以使用 Composer使用这个包了 Composer通常以“vendor/package” （厂商/包名）的方式来命名。这里我们为项目命名”bin/composer”。 测试地址 https://packagist.org/packages/bin/composer#v1.0.0 1.新建一个项目目录，创建一个composer.json文件，示例格式如下： 12345678910111213141516171819202122232425262728293031&#123; &quot;name&quot;: &quot;bin/composer&quot;, &quot;description&quot;: &quot;Testing and publishing composer packages&quot;, &quot;keywords&quot;: [&quot;laravel&quot;,&quot;composer&quot;], &quot;homepage&quot;: &quot;https://github.com/binbinmax/composer-packagist-test&quot;, &quot;type&quot;: &quot;library&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;require&quot;: &#123; &quot;php&quot;: &quot;^5.6.3 || ^7.0&quot;, &quot;overtrue/wechat&quot;: &quot;3.2.5&quot; &#125;, &quot;autoload&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Composer\\Bin\\&quot;: &quot;src/&quot; &#125; &#125;, &quot;minimum-stability&quot;: &quot;dev&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;bin&quot;, &quot;email&quot;: &quot;185910700@qq.com&quot;, &quot;homepage&quot;: &quot;https://www.vueyun.com&quot; &#125; ], &quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://packagist.phpcomposer.com&quot; &#125; &#125;&#125; 12这个json格式的文件中包含组件的基本信息，这里还差自动加载的方式，要根据具体开发模式指定自动加载方式，这里require可以指定这个组件依赖的其他组件，composer都会自动解决依赖 2.把组件提交到Github上 123456&quot;license&quot;: &quot;MIT&quot;,github 选择许可证这里选择的许可证是 MIT 许可证，只要用户在项目副本中包含了版权声明和许可声明 3.提交组件到Packagist之前需要先把代码提交到github上，在Packagist只需填写组件的github地址。 4.提交组件地址到Packagist/ (注册登录自己的Packagist账号) 1https://packagist.org/ - 目录结构 github地址 1https://github.com/binbinmax/composer-packagist-test packagist地址 1https://packagist.org/packages/bin/composer]]></content>
      <categories>
        <category>composer</category>
      </categories>
  </entry>
</search>
